{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"core-pool \u00b6 Features \u00b6 Support for HTTP and Stratum mining Detailed block stats with luck percentage and full reward Failover geth instances: geth high availability built in Separate stats for workers: can highlight timed-out workers so miners can perform maintenance of rigs JSON-API for stats New vue based UI Supports Ethereum Classic, Mordor, Ethereum, Ropsten & Ubiq.","title":"Home"},{"location":"#core-pool","text":"","title":"core-pool"},{"location":"#features","text":"Support for HTTP and Stratum mining Detailed block stats with luck percentage and full reward Failover geth instances: geth high availability built in Separate stats for workers: can highlight timed-out workers so miners can perform maintenance of rigs JSON-API for stats New vue based UI Supports Ethereum Classic, Mordor, Ethereum, Ropsten & Ubiq.","title":"Features"},{"location":"PAYOUTS/","text":"First of all make sure your Redis instance and backups are configured properly http://redis.io/topics/persistence . Keep in mind that pool maintains all balances in Shannon . Processing and Resolving Payouts \u00b6 You MUST run payouts module in a separate process , ideally don\u2019t run it as daemon and process payouts 2-3 times per day and watch how it goes. You must configure logging , otherwise it can lead to big problems. Module will fetch accounts and sequentially process payouts. For every account who reached minimal threshold: Check if we have enough peers on a node Check that account is unlocked If any of checks fails, module will not even try to continue. Check if we have enough money for payout (should not happen under normal circumstances) Lock payments If payments can\u2019t be locked (another lock exist, usually after a failure) module will halt payouts. Deduct balance of a miner and log pending payment Submit a transaction to a node via eth_sendTransaction If transaction submission fails, payouts will remain locked and halted in erroneous state. If transaction submission was successful, we have a TX hash: Write this TX hash to a database Unlock payouts And so on. Repeat for every account. After payout session, payment module will perform BGSAVE (background saving) on Redis if you have enabled bgsave option. Resolving Failed Payments (automatic) \u00b6 If your payout is not logged and not confirmed by Ethereum network you can resolve it automatically. You need to payouts in maintenance mode by setting up RESOLVE_PAYOUT=1 or RESOLVE_PAYOUT=True environment variable: RESOLVE_PAYOUT=1 ./build/bin/core-pool payouts.json . Payout module will fetch all rows from Redis with key eth:payments:pending and credit balance back to miners. Usually you will have only single entry there. If you see No pending payments to resolve we have no data about failed debits. If there was a debit operation performed which is not followed by actual money transfer (after eth_sendTransaction returned an error), you will likely see: Will credit back following balances: Address: 0xb85150eb365e7df0941f0cf08235f987ba91506a, Amount: 166798415 Shannon, 2016-05-11 08:14:34 followed by Credited 166798415 Shannon back to 0xb85150eb365e7df0941f0cf08235f987ba91506a Usually every maintenance run ends with following message and halt: Payouts unlocked Now you have to restart payouts module with RESOLVE_PAYOUT=0 for normal run Unset RESOLVE_PAYOUT=1 or run payouts with RESOLVE_PAYOUT=0 . Resolving Failed Payment (manual) \u00b6 You can perform manual maintenance using geth and redis-cli utilities. Check For Failed Transactions: \u00b6 Perform the following command in a redis-cli : ZREVRANGE \"eth:payments:pending\" 0 -1 WITHSCORES Result will be like this: 1) \u201c0xb85150eb365e7df0941f0cf08235f987ba91506a:25000000\u201d It\u2019s a pair of LOGIN:AMOUNT . 2) \u201c1462920526\u201d It\u2019s a UNIXTIME Manual Payment Submission \u00b6 Make sure there is no TX sent using block explorer. Skip this step if payment actually exist in a blockchain. eth . sendTransaction ({ from : eth . coinbase , to : '0xb85150eb365e7df0941f0cf08235f987ba91506a' , value : web3 . toWei ( 25000000 , 'shannon' ) }) // => 0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331 Write down tx hash . Store Payment in Redis \u00b6 Also usable for fixing missing payment entries. ZADD \"eth:payments:all\" 1462920526 0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331:0xb85150eb365e7df0941f0cf08235f987ba91506a:25000000 ZADD \"eth:payments:0xb85150eb365e7df0941f0cf08235f987ba91506a\" 1462920526 0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331:25000000 Delete Erroneous Payment Entry \u00b6 ZREM \"eth:payments:pending\" \"0xb85150eb365e7df0941f0cf08235f987ba91506a:25000000\" Update Internal Stats \u00b6 HINCRBY \"eth:finances\" pending -25000000 HINCRBY \"eth:finances\" paid 25000000 Unlock Payouts \u00b6 DEL \"eth:payments:lock\" Resolving Missing Payment Entries \u00b6 If pool actually paid but didn\u2019t log transaction, scroll up to Store Payment in Redis section. You should have a transaction hash from block explorer. Transaction Didn\u2019t Confirm \u00b6 If you are sure, just repeat it manually, you should have all the logs.","title":"Payouts"},{"location":"PAYOUTS/#processing-and-resolving-payouts","text":"You MUST run payouts module in a separate process , ideally don\u2019t run it as daemon and process payouts 2-3 times per day and watch how it goes. You must configure logging , otherwise it can lead to big problems. Module will fetch accounts and sequentially process payouts. For every account who reached minimal threshold: Check if we have enough peers on a node Check that account is unlocked If any of checks fails, module will not even try to continue. Check if we have enough money for payout (should not happen under normal circumstances) Lock payments If payments can\u2019t be locked (another lock exist, usually after a failure) module will halt payouts. Deduct balance of a miner and log pending payment Submit a transaction to a node via eth_sendTransaction If transaction submission fails, payouts will remain locked and halted in erroneous state. If transaction submission was successful, we have a TX hash: Write this TX hash to a database Unlock payouts And so on. Repeat for every account. After payout session, payment module will perform BGSAVE (background saving) on Redis if you have enabled bgsave option.","title":"Processing and Resolving Payouts"},{"location":"PAYOUTS/#resolving-failed-payments-automatic","text":"If your payout is not logged and not confirmed by Ethereum network you can resolve it automatically. You need to payouts in maintenance mode by setting up RESOLVE_PAYOUT=1 or RESOLVE_PAYOUT=True environment variable: RESOLVE_PAYOUT=1 ./build/bin/core-pool payouts.json . Payout module will fetch all rows from Redis with key eth:payments:pending and credit balance back to miners. Usually you will have only single entry there. If you see No pending payments to resolve we have no data about failed debits. If there was a debit operation performed which is not followed by actual money transfer (after eth_sendTransaction returned an error), you will likely see: Will credit back following balances: Address: 0xb85150eb365e7df0941f0cf08235f987ba91506a, Amount: 166798415 Shannon, 2016-05-11 08:14:34 followed by Credited 166798415 Shannon back to 0xb85150eb365e7df0941f0cf08235f987ba91506a Usually every maintenance run ends with following message and halt: Payouts unlocked Now you have to restart payouts module with RESOLVE_PAYOUT=0 for normal run Unset RESOLVE_PAYOUT=1 or run payouts with RESOLVE_PAYOUT=0 .","title":"Resolving Failed Payments (automatic)"},{"location":"PAYOUTS/#resolving-failed-payment-manual","text":"You can perform manual maintenance using geth and redis-cli utilities.","title":"Resolving Failed Payment (manual)"},{"location":"PAYOUTS/#check-for-failed-transactions","text":"Perform the following command in a redis-cli : ZREVRANGE \"eth:payments:pending\" 0 -1 WITHSCORES Result will be like this: 1) \u201c0xb85150eb365e7df0941f0cf08235f987ba91506a:25000000\u201d It\u2019s a pair of LOGIN:AMOUNT . 2) \u201c1462920526\u201d It\u2019s a UNIXTIME","title":"Check For Failed Transactions:"},{"location":"PAYOUTS/#manual-payment-submission","text":"Make sure there is no TX sent using block explorer. Skip this step if payment actually exist in a blockchain. eth . sendTransaction ({ from : eth . coinbase , to : '0xb85150eb365e7df0941f0cf08235f987ba91506a' , value : web3 . toWei ( 25000000 , 'shannon' ) }) // => 0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331 Write down tx hash .","title":"Manual Payment Submission"},{"location":"PAYOUTS/#store-payment-in-redis","text":"Also usable for fixing missing payment entries. ZADD \"eth:payments:all\" 1462920526 0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331:0xb85150eb365e7df0941f0cf08235f987ba91506a:25000000 ZADD \"eth:payments:0xb85150eb365e7df0941f0cf08235f987ba91506a\" 1462920526 0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331:25000000","title":"Store Payment in Redis"},{"location":"PAYOUTS/#delete-erroneous-payment-entry","text":"ZREM \"eth:payments:pending\" \"0xb85150eb365e7df0941f0cf08235f987ba91506a:25000000\"","title":"Delete Erroneous Payment Entry"},{"location":"PAYOUTS/#update-internal-stats","text":"HINCRBY \"eth:finances\" pending -25000000 HINCRBY \"eth:finances\" paid 25000000","title":"Update Internal Stats"},{"location":"PAYOUTS/#unlock-payouts","text":"DEL \"eth:payments:lock\"","title":"Unlock Payouts"},{"location":"PAYOUTS/#resolving-missing-payment-entries","text":"If pool actually paid but didn\u2019t log transaction, scroll up to Store Payment in Redis section. You should have a transaction hash from block explorer.","title":"Resolving Missing Payment Entries"},{"location":"PAYOUTS/#transaction-didnt-confirm","text":"If you are sure, just repeat it manually, you should have all the logs.","title":"Transaction Didn't Confirm"},{"location":"POLICIES/","text":"Enforcing Policies \u00b6 Pool policy server collecting several stats on per IP basis. There are two options: iptables+ipset or simple application level bans. Banning is disabled by default. Firewall Banning \u00b6 First you need to configure your firewall to use ipset , read this article . Specify ipset name for banning in policy section. Timeout argument (in seconds) will be passed to this ipset . Stratum will use os/exec command like sudo ipset add banlist x.x.x.x 1800 for banning, so you have to configure sudo properly and make sure that your system will never ask for password: Example /etc/sudoers.d/pool where pool is a username under which pool runs: pool ALL=NOPASSWD: /sbin/ipset If you need something simple, just set ipset name to blank string and simple application level banning will be used instead. Limiting \u00b6 Under some weird circumstances you can enforce limits to prevent connection flood to stratum, there are initial settings: limit and limitJump . Policy server will increase number of allowed connections per IP address on each valid share submission. Stratum will not enforce this policy for a grace period specified after stratum start.","title":"Policies"},{"location":"POLICIES/#enforcing-policies","text":"Pool policy server collecting several stats on per IP basis. There are two options: iptables+ipset or simple application level bans. Banning is disabled by default.","title":"Enforcing Policies"},{"location":"POLICIES/#firewall-banning","text":"First you need to configure your firewall to use ipset , read this article . Specify ipset name for banning in policy section. Timeout argument (in seconds) will be passed to this ipset . Stratum will use os/exec command like sudo ipset add banlist x.x.x.x 1800 for banning, so you have to configure sudo properly and make sure that your system will never ask for password: Example /etc/sudoers.d/pool where pool is a username under which pool runs: pool ALL=NOPASSWD: /sbin/ipset If you need something simple, just set ipset name to blank string and simple application level banning will be used instead.","title":"Firewall Banning"},{"location":"POLICIES/#limiting","text":"Under some weird circumstances you can enforce limits to prevent connection flood to stratum, there are initial settings: limit and limitJump . Policy server will increase number of allowed connections per IP address on each valid share submission. Stratum will not enforce this policy for a grace period specified after stratum start.","title":"Limiting"},{"location":"STRATUM/","text":"Stratum Mining Protocol \u00b6 This is the description of stratum protocol used in this pool. Stratum defines simple exception handling. Example of rejected share looks like: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : null , \"error\" : { code : 23 , message : \"Invalid share\" } } Each response with exception is followed by disconnect. Authentication \u00b6 Request looks like: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"method\" : \"eth_submitLogin\" , \"params\" : [ \"0xb85150eb365e7df0941f0cf08235f987ba91506a\" ] } Request can include additional 2nd param (email for example): { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"method\" : \"eth_submitLogin\" , \"params\" : [ \"0xb85150eb365e7df0941f0cf08235f987ba91506a\" , \"admin@example.net\" ] } Successful response: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : true } Exceptions: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : null , \"error\" : { code : - 1 , message : \"Invalid login\" } } Request For Job \u00b6 Request looks like: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"method\" : \"eth_getWork\" } Successful response: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : [ \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\" , \"0x5eed00000000000000000000000000005eed0000000000000000000000000000\" , \"0xd1ff1c01710000000000000000000000d1ff1c01710000000000000000000000\" ] } Exceptions: { \"id\" : 10 , \"result\" : null , \"error\" : { code : 0 , message : \"Work not ready\" } } New Job Notification \u00b6 Server sends job to peers if new job is available: { \"jsonrpc\" : \"2.0\" , \"result\" : [ \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\" , \"0x5eed00000000000000000000000000005eed0000000000000000000000000000\" , \"0xd1ff1c01710000000000000000000000d1ff1c01710000000000000000000000\" ] } Share Submission \u00b6 Request looks like: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"method\" : \"eth_submitWork\" , \"params\" : [ \"0xe05d1fd4002d962f\" , \"0x6c872e2304cd1e64b553a65387d7383470f22331aff288cbce5748dc430f016a\" , \"0x2b20a6c641ed155b893ee750ef90ec3be5d24736d16838b84759385b6724220d\" ] } Request can include optional worker param: { \"id\" : 1 , \"worker\" : \"rig-1\" /* ... */ } Response: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : true } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : false } Exceptions: Pool MAY return exception on invalid share submission usually followed by temporal ban. { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : null , \"error\" : { code : 23 , message : \"Invalid share\" } } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : null , \"error\" : { code : 22 , message : \"Duplicate share\" } } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : null , \"error\" : { code : - 1 , message : \"High rate of invalid shares\" } } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : null , \"error\" : { code : 25 , message : \"Not subscribed\" } } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : null , \"error\" : { code : - 1 , message : \"Malformed PoW result\" } } Submit Hashrate \u00b6 eth_submitHashrate is a nonsense method. Pool ignores it and the reply is always: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : true }","title":"Stratum"},{"location":"STRATUM/#stratum-mining-protocol","text":"This is the description of stratum protocol used in this pool. Stratum defines simple exception handling. Example of rejected share looks like: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : null , \"error\" : { code : 23 , message : \"Invalid share\" } } Each response with exception is followed by disconnect.","title":"Stratum Mining Protocol"},{"location":"STRATUM/#authentication","text":"Request looks like: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"method\" : \"eth_submitLogin\" , \"params\" : [ \"0xb85150eb365e7df0941f0cf08235f987ba91506a\" ] } Request can include additional 2nd param (email for example): { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"method\" : \"eth_submitLogin\" , \"params\" : [ \"0xb85150eb365e7df0941f0cf08235f987ba91506a\" , \"admin@example.net\" ] } Successful response: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : true } Exceptions: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : null , \"error\" : { code : - 1 , message : \"Invalid login\" } }","title":"Authentication"},{"location":"STRATUM/#request-for-job","text":"Request looks like: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"method\" : \"eth_getWork\" } Successful response: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : [ \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\" , \"0x5eed00000000000000000000000000005eed0000000000000000000000000000\" , \"0xd1ff1c01710000000000000000000000d1ff1c01710000000000000000000000\" ] } Exceptions: { \"id\" : 10 , \"result\" : null , \"error\" : { code : 0 , message : \"Work not ready\" } }","title":"Request For Job"},{"location":"STRATUM/#new-job-notification","text":"Server sends job to peers if new job is available: { \"jsonrpc\" : \"2.0\" , \"result\" : [ \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\" , \"0x5eed00000000000000000000000000005eed0000000000000000000000000000\" , \"0xd1ff1c01710000000000000000000000d1ff1c01710000000000000000000000\" ] }","title":"New Job Notification"},{"location":"STRATUM/#share-submission","text":"Request looks like: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"method\" : \"eth_submitWork\" , \"params\" : [ \"0xe05d1fd4002d962f\" , \"0x6c872e2304cd1e64b553a65387d7383470f22331aff288cbce5748dc430f016a\" , \"0x2b20a6c641ed155b893ee750ef90ec3be5d24736d16838b84759385b6724220d\" ] } Request can include optional worker param: { \"id\" : 1 , \"worker\" : \"rig-1\" /* ... */ } Response: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : true } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : false } Exceptions: Pool MAY return exception on invalid share submission usually followed by temporal ban. { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : null , \"error\" : { code : 23 , message : \"Invalid share\" } } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : null , \"error\" : { code : 22 , message : \"Duplicate share\" } } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : null , \"error\" : { code : - 1 , message : \"High rate of invalid shares\" } } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : null , \"error\" : { code : 25 , message : \"Not subscribed\" } } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : null , \"error\" : { code : - 1 , message : \"Malformed PoW result\" } }","title":"Share Submission"},{"location":"STRATUM/#submit-hashrate","text":"eth_submitHashrate is a nonsense method. Pool ignores it and the reply is always: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : true }","title":"Submit Hashrate"}]}